实现任意精度`Decimal`类.

浮点数是计算中非整数实数的最常见表示,它们是由...定义的通用标准[IEEE 754](https://en.wikipedia.org/wiki/IEEE_754).它们非常灵活和多功能,但它们确实有一些局限性.众所周知,在浮点运算中,[`0.1 + 0.2 != 0.3`](http://0.30000000000000004.com/).

这个问题的解决方案是找到另一种无损的方法来模拟任意精度的非整数实数.与浮点数相比,这在内存或处理速度方面可能效率较低;目标是提供准确的结果.

尽管`Decimal`作为一种自定义类型,我们仍然可以将它们视为数字:`==`,`<`,`>`,`+`,`-`,和`*`运算符应该在Decimals上按预期工作.为了方便起见,您不需要实现除法,因为任意精度除法很快就会失控.(你如何表示任意精度`1/3`?)

在Rust中,在自定义类型上获取这些操作的方法是实现自定义对象的相关特征.特别是,您至少需要实施`PartialEq`,`PartialOrd`,`Add`,`Sub`,和`Mul`.严格地说,假设十进制数形成一个总排序,你也应该实现`Eq`和`Ord`虽然这些测试没有检查这些特征.

# 注意

通过使用,可以很容易地实现这个练习[bigdecimal](https://crates.io/crates/bigdecimal)箱.不要那样做;自己实现这个.

# 提示

-   不要从头开始实现任意精度算术,而是考虑在上面构建类型[num_bigint](https://crates.io/crates/num-bigint)箱.
-   你也许能够[derive](https://doc.rust-lang.org/book/appendix-03-derivable-traits.html)一些必要的特征.
-   `Decimal`假定是签名类型.您不必创建单独的无符号类型,但如果您愿意,可以将其作为实现细节.
